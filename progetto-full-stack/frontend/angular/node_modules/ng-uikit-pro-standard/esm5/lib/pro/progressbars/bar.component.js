import { __decorate, __metadata, __param } from "tslib";
import { Component, Host, Input } from '@angular/core';
import { ProgressDirective } from './progress.directive';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './progress.directive';
import * as ɵngcc2 from '@angular/common';

var _c0 = function (a0, a1) { return { width: a0, transition: a1 }; };
var _c1 = ["*"];
var BarComponent = /** @class */ (function () {
    function BarComponent(progress) {
        this.percent = 0;
        this.progress = progress;
    }
    Object.defineProperty(BarComponent.prototype, "value", {
        /** current value of progress bar */
        get: function () {
            return this._value;
        },
        set: function (v) {
            if (!v && v !== 0) {
                return;
            }
            this._value = v;
            this.recalculatePercentage();
        },
        enumerable: true,
        configurable: true
    });
    BarComponent.prototype.ngOnInit = function () {
        this.progress.addBar(this);
    };
    BarComponent.prototype.ngOnDestroy = function () {
        this.progress.removeBar(this);
    };
    BarComponent.prototype.recalculatePercentage = function () {
        this.percent = +((100 * this.value) / this.progress.max).toFixed(2);
        var totalPercentage = this.progress.bars.reduce(function (total, bar) {
            return total + bar.percent;
        }, 0);
        if (totalPercentage > 100) {
            this.percent -= totalPercentage - 100;
        }
    };
    BarComponent.ctorParameters = function () { return [
        { type: ProgressDirective, decorators: [{ type: Host }] }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], BarComponent.prototype, "value", null);
    BarComponent = __decorate([ __param(0, Host()),
        __metadata("design:paramtypes", [ProgressDirective])
    ], BarComponent);
BarComponent.ɵfac = function BarComponent_Factory(t) { return new (t || BarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ProgressDirective, 1)); };
BarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarComponent, selectors: [["mdb-bar"]], inputs: { value: "value", type: "type" }, ngContentSelectors: _c1, decls: 2, vars: 8, consts: [["role", "progressbar", "aria-valuemin", "0", 1, "progress-bar", 2, "min-width", "0", 3, "ngClass", "ngStyle"]], template: function BarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.type && "progress-bar-" + ctx.type)("ngStyle", ɵngcc0.ɵɵpureFunction2(5, _c0, (ctx.percent < 100 ? ctx.percent : 100) + "%", ctx.transition));
        ɵngcc0.ɵɵattribute("aria-valuenow", ctx.value)("aria-valuetext", ctx.percent.toFixed(0) + "%")("aria-valuemax", ctx.max);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgStyle], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-bar',
                template: "<div class=\"progress-bar\"\nstyle=\"min-width: 0;\"\nrole=\"progressbar\"\n[ngClass]=\"type && 'progress-bar-' + type\"\n[ngStyle]=\"{width: (percent < 100 ? percent : 100) + '%', transition: transition}\"\naria-valuemin=\"0\"\n[attr.aria-valuenow]=\"value\"\n[attr.aria-valuetext]=\"percent.toFixed(0) + '%'\"\n[attr.aria-valuemax]=\"max\">\n  <ng-content></ng-content>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc1.ProgressDirective, decorators: [{
                type: Host
            }] }]; }, { value: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();
    return BarComponent;
}());
export { BarComponent };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFyLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsibmctdWlraXQtcHJvLXN0YW5kYXJkL2xpYi9wcm8vcHJvZ3Jlc3NiYXJzL2Jhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBcUIsTUFBTSxlQUFlLENBQUM7QUFFMUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7Ozs7Ozs7QUFNekQ7QUFBaUQsSUF5Qi9DLHNCQUEyQixRQUEyQjtBQUN2RCxRQVBRLFlBQU8sR0FBRyxDQUFDLENBQUM7QUFDcEIsUUFNRyxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUM1QixJQUFDLENBQUM7QUFFSCxJQXRCRSxzQkFBVywrQkFBSztBQUFLLFFBRnJCLG9DQUFvQztBQUNyQyxhQUNDO0FBQWUsWUFDYixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDdEIsUUFBQyxDQUFDO0FBRUYsYUFBQyxVQUFpQixDQUFTO0FBQzNCLFlBQUcsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ3RCLGdCQUFLLE9BQU87QUFDWixhQUFJO0FBQ0osWUFBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNuQixZQUFHLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0FBQ2hDLFFBQUMsQ0FBQztBQUVGO0FBQ0s7QUFDRCxPQVpGO0FBRUgsSUFrQlMsK0JBQVEsR0FBZjtBQUFlLFFBQ2IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDOUIsSUFBQyxDQUFDO0FBRUYsSUFBUSxrQ0FBVyxHQUFsQjtBQUFlLFFBQ2IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsSUFBQyxDQUFDO0FBRUYsSUFBUSw0Q0FBcUIsR0FBNUI7QUFBZSxRQUNiLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUV4RSxRQUFJLElBQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUNoRCxLQUFhLEVBQ2IsR0FBaUI7QUFDbkIsWUFDRSxPQUFPLEtBQUssR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDO0FBQ2hDLFFBQUcsQ0FBQyxFQUNELENBQUMsQ0FBQyxDQUFDO0FBRVAsUUFBSSxJQUFJLGVBQWUsR0FBRyxHQUFHLEVBQUU7QUFDOUIsWUFBSyxJQUFJLENBQUMsT0FBTyxJQUFJLGVBQWUsR0FBRyxHQUFHLENBQUM7QUFDM0MsU0FBSTtBQUNKLElBQUMsQ0FBQztBQUVIO0FBQTBELGdCQTVCbkIsaUJBQWlCLHVCQUFsQyxJQUFJO0FBQU87QUFBVyxJQXJCakM7QUFBYyxRQUF0QixLQUFLLEVBQUU7QUFBRztBQUNXLDhDQURPO0FBQzdCLElBRUE7QUFBYyxRQURiLEtBQUssRUFBRTtBQUNSO0FBQ2E7QUFJViw2Q0FIRjtBQUVGLElBWFksWUFBWSx5QkFKeEIsU0FBUyxDQUFDLHBCQUlGLENBeUJhLFdBQUEsSUFBSSxFQUFFLENBQUE7YUE1QjFCLFFBQVEsRUFBRSxTQUFTLGVBQ25CLC9DQTJCNkIseUNBQVEsaUJBQWlCO0FBQ3hELE9BMUJhLFlBQVksQ0FvRHhCOzttTkF0RG9DLFdBQ3BDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFzREY7QUFBRSxJQURGLG1CQUFDO0FBQ0MsQ0FERCxBQXBERCxJQW9EQzs7QUE1REEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQU1BLEFBeUJBLEFBQUEsQUFBQSxBQU5BLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFPQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFwQkEsQUFBQSxBQUFBLEFBRkEsQUFBQSxBQUVBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQVJBLEFBb0JBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQTFCQSxBQUFBLEFBQUEsQUFBQSxBQXJCQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBR0EsQUFEQSxBQUFBLEFBQUEsQUFHQSxBQVRBLEFBQUEsQUFKQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBMEJBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBekJBLEFBQUEsQUFvREEsQUFBQSxBQUFBLEFBQUEsQUFwREEsQUFvREEsQUFwREEsQUFBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSG9zdCwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFByb2dyZXNzRGlyZWN0aXZlIH0gZnJvbSAnLi9wcm9ncmVzcy5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtZGItYmFyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2Jhci5jb21wb25lbnQuaHRtbCcsXG59KVxuZXhwb3J0IGNsYXNzIEJhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgcHVibGljIG1heDogbnVtYmVyO1xuXG4gIC8qKiBwcm92aWRlIG9uZSBvZiB0aGUgZm91ciBzdXBwb3J0ZWQgY29udGV4dHVhbCBjbGFzc2VzOiBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCAqL1xuICBASW5wdXQoKSBwdWJsaWMgdHlwZTogc3RyaW5nO1xuICAvKiogY3VycmVudCB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGdldCB2YWx1ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgdmFsdWUodjogbnVtYmVyKSB7XG4gICAgaWYgKCF2ICYmIHYgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIHRoaXMucmVjYWxjdWxhdGVQZXJjZW50YWdlKCk7XG4gIH1cblxuICBwdWJsaWMgcGVyY2VudCA9IDA7XG4gIHB1YmxpYyB0cmFuc2l0aW9uOiBzdHJpbmc7XG4gIHB1YmxpYyBwcm9ncmVzczogUHJvZ3Jlc3NEaXJlY3RpdmU7XG5cbiAgcHJvdGVjdGVkIF92YWx1ZTogbnVtYmVyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihASG9zdCgpIHByb2dyZXNzOiBQcm9ncmVzc0RpcmVjdGl2ZSkge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnByb2dyZXNzLmFkZEJhcih0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnByb2dyZXNzLnJlbW92ZUJhcih0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyByZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5wZXJjZW50ID0gKygoMTAwICogdGhpcy52YWx1ZSkgLyB0aGlzLnByb2dyZXNzLm1heCkudG9GaXhlZCgyKTtcblxuICAgIGNvbnN0IHRvdGFsUGVyY2VudGFnZSA9IHRoaXMucHJvZ3Jlc3MuYmFycy5yZWR1Y2UoZnVuY3Rpb24oXG4gICAgICB0b3RhbDogbnVtYmVyLFxuICAgICAgYmFyOiBCYXJDb21wb25lbnRcbiAgICApOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRvdGFsICsgYmFyLnBlcmNlbnQ7XG4gICAgfSxcbiAgICAwKTtcblxuICAgIGlmICh0b3RhbFBlcmNlbnRhZ2UgPiAxMDApIHtcbiAgICAgIHRoaXMucGVyY2VudCAtPSB0b3RhbFBlcmNlbnRhZ2UgLSAxMDA7XG4gICAgfVxuICB9XG59XG4iXX0=